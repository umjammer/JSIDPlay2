What is this package all about?
===============================

This is about integration of C64 content in your web site using JSIDPlay2.

Quickstart:
===========
If you don't care how it works and just want to jump-start to add it into your web-page,
just use the file set and upload to your web server.
I have added example HTML code for different use-cases. Use it or add the code to your web-site HTML code.
example-sound.html - Choose a tune and play a SID
example-video.html - Choose a tune and play a SID while watching the video screen.
example-disk.html - Choose a disk image, reset C64 and load first entry. For disk swap just choose another disk
c64jukebox.vue and c64jukebox.scss - Is a complex example using VUE and Bootstrap dependencies for web developers just for completeness

Background Story:
=================

JSIDPlay2 is a Java based C64 emulator and since Java is not popular to be installed on the client side
for security reasons or taste, i have therefore presumably a small user base.

On the client side in a browser JavaScript dominates since the beginning as a de-facto standard for web development.
Even more modern frameworks are based on JavaScript.

But web content uses more and more logic and JavaScript is quite often megabytes of code to be executed on the client side. 
Web sites tend to get slower and slower due to this fact.
The World Wide Web consortium (W3C) knows well about the problem and has created a new standard to not replace, but to
extend JavaScript by a new language called "Web Assembly". It can be executed near native speed.

But they have learned from the past. Do you remember where Java shipped with a browser plugin and the security risk was always high?
Web Assembly in contrast can only be used for computational tasks. There is zero I/O possibilities.
That makes Web Assembly a safe technology. Whenever I/O operations must happen, JavaScript code is required.

Many programming languages can convert source code to web assembly including C/C++, Python and so on.
Java is no exception here, even though it is not a trivial task, since a garbage collector is always required to free memory during execution.
For Java there are several tools out there like  GWT, TeaVM or CherpJ. Each of them with different possibilities.
One of them - TeaVM - is a great project out there, that makes it possible to get Java code executed on the client side in a different form.
This magic is done using the intermediate language of Java, the class files, and execution by ahead-of-time compilation.
The output is emitted as JavaScript or Web Assembly.

Using class files, not Java source code - makes it possible to use it with other programming languages than Java as well, like Scala and Kotlin,
that compiles to class files as well.

TeaVM can be used with maven or gradle.
No other technology stack is required, just what we already use: maven and a Java IDE is just fine.

If you want to learn more about TeaVM, please visit the project at "https://teavm.org/".

I got curious about the idea to make use of this project, even though the documentation is sparse.
Is it able to use my emulation core and push a decent Java emulator like JSIDPlay2 to the client side?
It took me some weeks, but fair to say, there was only minimum problems I got to solve for my code base to make that happen.
1. If you need resources like ROMs, you need to read it during compilation phase and put it in the resulting JavaScript,
   since you can't just read a file from hard disk in a browser like in Java.
   Same for the PAL emulation color palette. It is 2MB big and calculation would be just too slow for the client side.
   Therefore it's pre-calculated.
2. Are there bugs in TeaVM? Very few. Take care of two dimensional arrays. TeaVM does not directly allocate the second dimension
   and the length is always 0 by the time being! And a method with a try-catch operation in a switch statement was a problem as well.
   Some JDK class library code is not 100% compatible, but it gets better and better and is still actively developed.
   There is nearly 0 other bugs at least I have found.
   Nearly every class of the JDK library is available, with some exceptions. Reflection is only partly implemented, though.
3. Debugging of Web Assembly is currently unsupported. When I started by generating Web-Assembly, first, it was a bad decision.
   I thought it would be a good idea, because it would be faster than JavaScript. But against any expectations the opposite is the case
   at least for my use case. And then, when I added JavaScript,
   I made wide eyes finding debugging possibilities in the browser developer console.
   Additionally if we are talking about the speed - the speed is so incredible fast, you won't believe it at least in Google Chrome browser.
   Don't think that JavaScript is still an interpreted slow language, browser vendors do a fantastic job these days to get maximum speed out of it.
4. Optimize your code for speed. Don't execute any unnecessary piece of code. This is the most important rule to get good results!

Now, as a result, you can directly compare both, JavaScript and Web Assembly version of JSIDPlay2 to find out what works better for you.

Enough talking.

What does the package of JSIDPlay2 contain:
===========================================
So, the package contains the basic functionality of JSIDPlay2 (namely the package libsidplay).
A complete hardware setup with C64, Floppy, Datasette, Cartridge support and more.
   
It can play C64 content like SID music, executable programs (PRG) or
even content from tape, disk or cartridge for your enjoyment.

What files do I need?
=====================
ZIP file contains several demo HTML pages on the root level just for you to learn how it works.
The sub-directory js (or wasm) contains the generated emulator file jsidplay2.js (JavaScript) or jsidplay2.wasm (Web Assembly).
Both releases have an additional web worker (*-worker*.js) and Web Assembly requires a runtime in JavaScript (*-runtime*.js).
That's it.
2 files for JavaScript or 3 for Web Assembly and thats all you need
In any case you will need these files from the sub folder js/wasm for integration in your web site.

Required Files for JavaScript version:
jsidplay2-js-worker.js			web worker
jsidplay2.js					generated JSIDPlay2 as JavaScript

...or as an alternative...
Required Files for Web Assembly version:
jsidplay2-wasm-worker.js		web worker
jsidplay2.wasm					generated JSIDPlay2 as Web Assembly
jsidplay2.wasm-runtime.js		runtime JavaScript file to use the Web Assembly

Upload this file set to your web server and then you need a bit JavaScript in your main page to start controlling the emulator.

What code do I need to control the emulator?
============================================
Since the emulator runs as a web worker (to not block the main thread), you will setup this worker, first,
calling wasmWorker(...).

Parameters of wasmWorker:
What tune to play is answered by the first two parameters. "contents" and "tune name" are specifying a tune to play.
1. contents - Uint8Array with the PSID, PRG, P00 or T64
2. tuneName - the tune name must be present and contain a file extension one of ".sid", ".prg", ".p00", ".t64"
If a cartridge is required, please specify the next similar two parameters.
The cartridge can be a multi purpose cartridge like EasyFlash, Action Replay and more. GeoRAM and REU is currently not supported
3. cartContents - Uint8Array with the cartridge
4. cartName - the cartridge name
Some content needs a start command to load from disk or tape. Therefore you can set it with the next parameter.
5. command - Start command to be used (e.g. 'LOAD"*",8,1\rRUN\r' or 'LOAD\rRUN\r').

Code Snippet:
==================================================

      function wasmWorker(contents, tuneName, cartContents, cartName, command) {
        // terminate last emulation instance
        if (worker) {
          worker.terminate();
          worker = undefined;
        }
        // create a new emulator
        worker = new Worker("${teaVMFormat}/jsidplay2-${teaVMFormat}-worker.js", ${teaVMWorkerAttrs});

        return new Promise((resolve, reject) => {
          // Everything starts with INITIALISE where basic configuration is provided
          worker.postMessage({
            eventType: "INITIALISE",
            eventData: {
              palEmulation: true,							// PAL emulation on/off
              bufferSize: 144000,							// how many clock ticks to advance per call of clock()?
              audioBufferSize: 48000,						// audio buffer fill level, until a chunk of samples is reported
              samplingRate: 48000,							// sampling rate
              samplingMethodResample: false,				// resampling method DECIMATE (false) or RESAMPLE (true)
              reverbBypass: true,							// Reverb on (false) or off (true)
              defaultClockSpeed: 50,						// PAL (50) or NTSC (60)
              defaultSidModel: true,						// default MOS6581 (false) or MOS8580 (true)
              jiffyDosInstalled: false,						// Floppy speeder off/on
              defaultEmulation: false,						// default emulation engine RESIDFP (false) or RESID (true)
            },
          });

          // We listen to  events from JSIDPlay2 worker as well, because it responds to our event calls as well
          worker.addEventListener("message", function (event) {
            var { eventType, eventData } = event.data;

            if (eventType === "SAMPLES") {
              // the worker has produced a chunk of sound data. We create a stereo buffer and send it to the sound card
              var buffer = audioContext.createBuffer(2, eventData.left.length, audioContext.sampleRate);
              buffer.getChannelData(0).set(eventData.left);
              buffer.getChannelData(1).set(eventData.right);

              var sourceNode = audioContext.createBufferSource();
              sourceNode.buffer = buffer;
              sourceNode.connect(audioContext.destination);

              // some magic to stay in sync, please experiment for yourself, if needed
              if (nextTime == 0) {
                fix = app.screen ? 0.005 : 0;
                nextTime = audioContext.currentTime + 0.05; // add 50ms latency to work well across systems
              } else if (nextTime < audioContext.currentTime) {
                nextTime = audioContext.currentTime + 0.005; // if samples are not produced fast enough
              }
              sourceNode.start(nextTime);
              nextTime += eventData.left.length / audioContext.sampleRate + fix;
            } else if (eventType === "FRAME") {
              // the worker has produced a video frame to display. Since it does it 50 times per second,
              // we need a queue here and display one frame every 1/50 (PAL) or 1/60 (NTSC) per second
              imageQueue.enqueue({
                image: eventData.image,
              });
            } else if (eventType === "SID_WRITE") {
              // The worker notifies about a SID write to the SID chip. We can ignore/report or send it to an USB device here.
              console.log("relTime=" + eventData.relTime + ", addr=" + eventData.addr + ", value=" + eventData.value);
            } else if (eventType === "OPENED" || eventType === "CLOCKED") {
              // Every time a tune gets opened, we start the clocking here. After clocking, we clock again and so on.
              if (eventType === "OPENED") {
                // Maybe we must insert media, because the tune requires it, but its optional.
                insertDisk();
                insertTape();
              }
              // The idea of sending IDLE states, where NO clocking is done at all is simple:
              // the emulator must not run and produce frames and samples faster than a person can watch, therefore the braking here.
              // To do so, please check the frame queue's fill state (size). In pause mode we just send idle events as well.
              if (!paused && size < 60) {
                // clock the emulator to produce more samples and frames
                worker.postMessage({ eventType: "CLOCK" });
              } else {
                // get on the brakes
                worker.postMessage({ eventType: "IDLE" });
              }
            } else if (eventType === "INITIALISED") {
              // If the emulation instance is initialized, the tune can be opened to play. This is required before clocking.
              worker.postMessage({
                eventType: "OPEN",
                eventData: {
                  contents: contents,						// tune as Uint8Array
                  tuneName: tuneName,						// tune name with extension for type detection
                  startSong: 0,								// a tune can contain several songs, you can specify the song to play here
                  nthFrame: 0,								// we capture every Nth frame for performance reasons. 0 means no frame output at all (only audio)
                  sidWrites: false,							// If SID writes should be captured, set to true here
                  cartContents: cartContents,				// cartridge data as Uint8Array
                  cartName: cartName,						// cartridge name
                  command: command,							// Command to enter after C64 reset to play the tune a.g. Load commmand
                },
              });

              nextTime = 0;
              // clear your queue of frames, here
              imageQueue.clear();
              // If you want to capture and show frames, start a timer and pull the queued elements at a rate of 1/50 (PAL) or 1/60 (NTSC)
              (start = new Date().getTime()), (time = 0);
              showFrame();
            }
          });

          worker.addEventListener("error", function (error) {
            reject(error);
          });
        });
      }
      // periodically show frames during playback
      function showFrame() {
        var timeSpan = 1000 / 50;
        time += timeSpan;
        if (!paused) {
          var elem = imageQueue.dequeue();
          if (elem) {
            data.set(elem.image);
            canvasContext.putImageData(imageData, 0, 0);
          }
        }
        var diff = new Date().getTime() - start - time;
        if (playing) setTimeout(() => showFrame(), timeSpan - diff);
      }

=====================================
To communicate with the web worker as always, events are required.
Events consists of EventType and EventData.

The events can be imagined as a request and response ping pong protocol between your web site and the emulation web worker.
Nearly every command event has an answer event to report fullfillment.

Event Types:
"INITIALISE" - Every emulation instance starts calling that first event with some configuration. The worker answers with INITIALISED
"INITIALISED"- Now we open a tune calling the OPEN event with details of the tune
"OPEN"       - Open a tune file (load it, setup the emulator to play it), the answer will be "OPENED"
"OPENED"     - The emulator has opened a tune and is ready to get clocked. During clocking it produces output (samples and frames)
"CLOCK"      - The emulator clocks the C64 hardware (the buffer size denotes how many times).
               During that clocking it reports "SAMPLES" (with the size of audioBufferSize), "FRAME" (every generated video frame)
               and "SID_WRITE" events on each CPU write to the SID chip. If clocking is completed, the answer is "CLOCKED"
               and the "CLOCK" event gets started again or the next round
"IDLE"       - This event does in fact nothing (no output is produced), since the queue is full and waiting until the viewer
               watches and listens recently created output. However, the answer is "CLOCKED" as well even though nothing advanced.
These events from the emulation web worker have no answer and are called during clocking:
"SAMPLES"    - the worker has produced a chunk of sound data (size of audioBufferSize). You can send it further to the JavaScript Audio API
"FRAME"      - A video frame has been produced. Send it to a queue and pull it every 1/50s to a canvas for watching.
"SID_WRITE"  - A SID write statement occurs, ignore it, print it or send it to an USB connected virtual SID device using some driver code

That's the trick, easy eh?
I hope it helps you.
If you are missing features in the API or have further questions, please contact me by email: kschwiersch@yahoo.de
