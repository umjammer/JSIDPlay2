<!DOCTYPE html>
<html>
  <head> </head>
  <body>
    <input id="file" type="file" />
    <button type="button" onclick="startTune()">Play</button>
    <button type="button" onclick="pauseTune()" id="pause">Pause</button>
    <button type="button" onclick="stopTune()">Stop</button>

    <div style="width: 100%; margin: 0px auto">
      <canvas
        id="c64Screen"
        style="border: 2px solid black; background-color: black; max-width: 100vw"
        width="384"
        height="285"
      />
    </div>

    <script>
      var size = 0;
      function Queue() {
        var head, tail;
        return Object.freeze({
          enqueue(value) {
            const link = { value, next: undefined };
            tail = head ? (tail.next = link) : (head = link);
            size++;
          },
          dequeue() {
            if (head) {
              var value = head.value;
              head = head.next;
              size--;
              return value;
            }
            return undefined;
          },
          peek() {
            return head?.value;
          },
          clear() {
            tail = head = undefined;
            size = 0;
          },
          isNotEmpty() {
            return head;
          },
        });
      }
      const maxWidth = 384;
      const maxHeight = 312;

      var worker;
      var AudioContext = window.AudioContext || window.webkitAudioContext;
      var audioContext;
      var nextTime, pause;

      var canvasContext;
      var imageData, data;
      var imageQueue = new Queue();
      var start, time;
      var nthFrame = 2;

      var playing;

      var canvas = document.getElementById("c64Screen");
      canvasContext = canvas.getContext("2d");
      imageData = canvasContext.getImageData(0, 0, maxWidth, maxHeight);
      data = imageData.data;

      function wasmWorker(contents, tuneName, cartContents, cartName, command) {
        audioContext = new AudioContext({
          latencyHint: "interactive",
          sampleRate: 48000,
        });

        if (worker) {
          worker.terminate();
          worker = undefined;
        }
        worker = new Worker("${teaVMFormat}/jsidplay2-${teaVMFormat}-worker.js", ${teaVMWorkerAttrs});

        return new Promise((resolve, reject) => {
          worker.postMessage({
            eventType: "INITIALISE",
            eventData: {
              palEmulation: true,
              bufferSize: 144000,
              audioBufferSize: 48000,
              samplingRate: 48000,
              samplingMethodResample: false,
              reverbBypass: true,
              defaultClockSpeed: 50,
              defaultSidModel: true,
              jiffyDosInstalled: false,
              defaultEmulation: false,
              filter6581: 'FilterAverage6581',
              filter8580: 'FilterAverage8580',
              stereoFilter6581: 'FilterAverage6581',
              stereoFilter8580: 'FilterAverage8580',
              thirdSIDFilter6581: 'FilterAverage6581',
              thirdSIDFilter8580: 'FilterAverage8580',
              reSIDfpFilter6581: 'FilterAlankila6581R4AR_3789',
              reSIDfpFilter8580: 'FilterTrurl8580R5_3691',
              reSIDfpStereoFilter6581: 'FilterAlankila6581R4AR_3789',
              reSIDfpStereoFilter8580: 'FilterTrurl8580R5_3691',
              reSIDfpThirdFilter6581: 'FilterAlankila6581R4AR_3789',
              reSIDfpThirdFilter8580: 'FilterTrurl8580R5_3691',
            },
          });

          worker.addEventListener("message", function (event) {
            var { eventType, eventData } = event.data;

            if (eventType === "SAMPLES") {
              var buffer = audioContext.createBuffer(2, eventData.left.length, audioContext.sampleRate);
              buffer.getChannelData(0).set(eventData.left);
              buffer.getChannelData(1).set(eventData.right);

              var sourceNode = audioContext.createBufferSource();
              sourceNode.buffer = buffer;
              sourceNode.connect(audioContext.destination);

              if (nextTime == 0) {
                nextTime = audioContext.currentTime + 0.05; // add 50ms latency to work well across systems
              } else if (nextTime < audioContext.currentTime) {
                nextTime = audioContext.currentTime + 0.005; // if samples are not produced fast enough
              }
              sourceNode.start(nextTime);
              nextTime += eventData.left.length / audioContext.sampleRate + 0.005;
            } else if (eventType === "FRAME") {
              imageQueue.enqueue({
                image: eventData.image,
              });
            } else if (eventType === "SID_WRITE") {
            } else if (eventType === "OPENED" || eventType === "CLOCKED") {
              if (!pause) {
                worker.postMessage({ eventType: "CLOCK" });
              } else {
                worker.postMessage({ eventType: "IDLE" });
              }
              worker.postMessage({ eventType: "CLOCK" });
            } else if (eventType === "INITIALISED") {
              worker.postMessage({
                eventType: "OPEN",
                eventData: {
                  contents: contents,
                  tuneName: tuneName,
                  startSong: 0,
                  nthFrame: nthFrame,
                  sidWrites: false,
                  cartContents: cartContents,
                  cartName: cartName,
                  command: command,
                },
              });
            }
          });

          worker.addEventListener("error", function (error) {
            reject(error);
          });

          nextTime = 0;
          imageQueue.clear();
          playing = true;
          (start = new Date().getTime()), (time = 0);
          showFrame();
        });
      }

      function startTune() {
        stopTune();
        var file = document.getElementById("file");
        if (file.files[0]) {
          var reader = new FileReader();
          reader.onload = function () {
            wasmWorker(new Uint8Array(this.result), file.files[0].name);
          };
          reader.readAsArrayBuffer(file.files[0]);
        }
      }
      function stopTune() {
        if (worker) {
          worker.terminate();
          worker = undefined;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = undefined;
        }
        pause = false;
        var pauseBtn = document.getElementById("pause");
        pauseBtn.style.color = "black";
        playing = false;
      }
      function pauseTune() {
        pause = !pause;
        var pauseBtn = document.getElementById("pause");
        if (pause) {
          audioContext.suspend();
          pauseBtn.style.color = "red";
        } else {
          audioContext.resume();
          pauseBtn.style.color = "black";
        }
      }
      function showFrame() {
        var timeSpan = (1000 * nthFrame) / 50;
        time += timeSpan;
        if (!pause) {
          var elem = imageQueue.dequeue();
          if (elem) {
            data.set(elem.image);
            canvasContext.putImageData(imageData, 0, 0);
          }
        }
        var diff = new Date().getTime() - start - time;
        if (playing) setTimeout(() => showFrame(), timeSpan - diff);
      }
    </script>
  </body>
</html>
